#!/bin/bash

# A bash script to package a python virtualenv into a transportable
# file that can be moved to another machine and file system.
#
# Copyright Mark Betz, All Rights Reserved
#
#
# Project home page: https://github.com/Markbnj/venvpack

version="0.1.0-beta"
venv_root="${VIRTUALENVWRAPPER_HOOK_DIR}/"
venv=
venv_file=
project_path=
project_dir=
project_base=
outfile=
debug=false
restore=false
force=false
cwd=$(pwd)
no_prompt=false
venv_path_placer="##VENVPACK_VENV##"
project_path_placer="##VENVPACK_PROJ##"
tmp_dir=

show_help() {
    echo "venvpack ${version}"
    echo
    echo "USAGE: venvpack [OPTION]... [TARGET]"
    echo
    echo "Package a python virtualenv into a single transportable file that"
    echo "can be moved between file systems."
    echo
    echo "In the normal mode of operation the script packages a virtualenv into"
    echo "a single file, and TARGET refers to the virtual env name. If TARGET is"
    echo "not supplied the current active virtualenv, if any, is packaged."
    echo
    echo "If the -o|--outfile option is not supplied the output file will be"
    echo "given the same name as the source virtualenv."
    echo
    echo "When the -r|--restore option is used to restore a virtualenv TARGET"
    echo "is the path and name of the .venv file, and is required."
    echo
    echo "Example:"
    echo "    venvpack testenv"
    echo
    echo "Packages the testenv virtualenv into 'testenv.venv' in the current"
    echo "working directory."
    echo
    echo "Example:"
    echo "    venvpack --restore testenv.venv"
    echo
    echo "Restores the packaged virtualenv in testenv.venv into the local"
    echo "filesystem."
    echo
    echo "Options:"
    printf "\t-d, --debug\t\t\t\tPrint diagnostic information after packaging.\n"
    printf "\t-f, --force\t\t\t\tForce restoring even if architecture check fails.\n"
    printf "\t-o, --outfile=PATH\t\tSpecify the output file name and path.\n"
    printf "\t-r, --restore\t\t\tRestore a packaged virtualenv.\n"
    printf "\t-y, --no-prompt\t\t\tDo not prompt for confirmation before building.\n"
    echo
    if [ ! -z "${1}" ]; then
        exit $1
    else
        exit 0
    fi
}

# check to be sure we were passed a valid venv, otherwise detect
# the current active venv, set venv to the full path to the environment
ensure_venv() {
    if [ "${restore}" = "true" ]; then
        if [ ! -d "${VIRTUALENVWRAPPER_HOOK_DIR}" ]; then
            echo "Error: VIRTUALENVWRAPPER_HOOK_DIR does not point to the virtualenv root."
            echo "Check that virtualenv is installed for this user."
            exit 1
        fi
        if [ -d "${outfile}" ]; then
            project_base=${outfile}
        elif [ -d "${PROJECT_HOME}" ]; then
            project_base=${PROJECT_HOME}
        else
            echo "Error: PROJECT_HOME is unset or does not point to a valid directory."
            echo "Use the --outfile option to set the project base path."
            exit 1
        fi
        project_path=${project_base}/${project_dir}
    else
        if [ ! -z "${venv}" ]; then
            if [ ! -d "${venv_root}${venv}" ]; then
                echo "Error: virtual env '${venv}' not found at ${venv_root}"
                exit 1
            fi
        else
            if [ -z "${VIRTUAL_ENV}" ]; then
                echo "Error: virtual env not specified and no active virtual environment"
                echo "found."
                echo
                show_help 1
            else
                venv=$(basename ${VIRTUAL_ENV})
            fi
        fi
        # get the project directory from the virtualenv
        project_path=$( cat ${venv_root}${venv}/${VIRTUALENVWRAPPER_PROJECT_FILENAME} )
        if [ -z "${project_path}" ]; then
            echo "Error: could not find project home for env $venv"
            exit 1
        fi
        project_dir=$( basename ${project_path} )
        project_base=$( dirname ${project_path} )
    fi
}

# gets the project and venv names from the file we're restoring.
get_names_from_file() {
    files=($( tar --list -f ${venv_file} ))
    if [ ${#files[@]} -gt 0 ]; then
        for file in ${files[@]}; do
            if [[ ${file} == *.sys.tar ]]; then
                name_split=($(echo ${file} | tr "." "\n"))
                venv=${name_split[0]}
                unset name_split
            else
                name_split=($(echo ${file} | tr "." "\n"))
                project_dir=${name_split[0]}
                unset name_split
            fi
        done
    else
        echo "Error: could not list files in ${venv_file}. File may be corrupt or path may be incorrect."
        exit 1
    fi
}

pack_venv() {
    # get some temporary working space
    tmp_dir=$(mktemp -d)
    if [ ! -d "${tmp_dir}" ]; then
        echo "Error: could not get temporary directory to work in."
        exit 1
    fi

    # since we will not patch anything in the project files just tar them right
    # into the temp folder
    if [ -d "${project_path}" ]; then
        echo "Packing ${project_path} to ${tmp_dir} ..."
        if $( tar --directory=${project_path}/.. -cf ${tmp_dir}/${project_dir}.tar ./${project_dir} --exclude=*.pyc ); then
            echo "${project_path} complete"
        else
            echo "Error: failed to archive ${project_path} to ${tmp_dir}/${project_dir}; check directory and file permissions."
            exit 1
        fi
    else
        echo "Warning: ${project_path} not found; skipping"
    fi

    # now stage the venv files to tmp so we can patch the paths with a
    # placeholder
    echo "Copying ${venv_root}${venv} to ${tmp_dir} ..."
    if $( tar -c --directory=${venv_root} ./${venv} --exclude=*.pyc | tar -x --directory=${tmp_dir} ); then
        echo "${venv_root}${venv} copied."
    else
        echo "Error: failed to copy ${venv_root}${venv} to ${tmp_dir}; check directory and file permissions."
        exit 1
    fi

    # patch the paths
    echo "Patching paths in ${tmp_dir}/${venv} ..."
    files=$( grep ${venv_root} -l --recursive --exclude=*.pyc ${tmp_dir}/${venv} )
    for file in $files; do
        echo "Patching $file ..."
        sed -i"" -e "s:${venv_root}:${venv_path_placer}:g" $file
    done
    files=$( grep ${project_base} -l --recursive --exclude=*.pyc ${tmp_dir}/${venv} )
    for file in $files; do
        echo "Patching $file ..."
        sed -i"" -e "s:${project_base}:${project_path_placer}:g" $file
    done

    # tar into temp directory
    echo "Packing ${tmp_dir}/${venv} to ${tmp_dir} ..."
    if $( tar --directory=${tmp_dir} -cf ${tmp_dir}/${venv}.sys.tar ./${venv} ); then
        echo "${tmp_dir}/${venv} complete"
        echo "Removing temporary files ..."
        if $(rm -rf ${tmp_dir}/${venv}); then
            echo "Temporary files in ${tmp_dir}/${venv} removed"
        else
            echo "Warning: unable to remove staging folder ${tmp_dir}/${venv}"
        fi
    else
        echo "Error: failed to pack ${tmp_dir}/${venv}; check directory and file permissions."
        exit 1
    fi

    echo "System files completed."

    # last step zip up the final product to the output path
    echo "Creating archive file as ${outfile} ..."
    if $( tar --directory=${tmp_dir} -cf ${outfile} ${venv}.sys.tar ${project_dir}.tar ); then
        echo "File ${outfile} completed."
    else
        echo "Error: failed to create ${outfile}; check directory and file permissions."
        echo "Warning: source files remain in ${tmp_dir}"
        exit 1
    fi
    rm -rf ${tmp_dir}
}

unpack_venv() {
    # get some temporary working space
    tmp_dir=$(mktemp -d)
    if [ ! -d "${tmp_dir}" ]; then
        echo "Error: could not get temporary directory to work in."
        exit 1
    fi

    # untar the archive file into the temp directory
    echo "Unpacking ${venv_file} to ${tmp_dir} ..."
    if $( tar --directory=${tmp_dir} -xf ${venv_file} ); then
        echo "$venv_file unpacked."
    else
        echo "Error: could not unpack ${venv_file} to ${tmp_dir}. Check file and directory permissions."
        exit 1
    fi

    # untar the project archive into the destination directory
    echo "Unpacking ${tmp_dir}/${project_dir}.tar to ${project_path} ..."
    if $( tar --directory=${project_base} -xf ${tmp_dir}/${project_dir}.tar ); then
        echo "${project_path} restored."

    else
        echo "Error: could not unpack ${project_dir}.tar to ${project_base}. Check file and directory permissions."
        exit 1
    fi

    # untar the venv system archive into the temp folder so we can patch
    echo "Unpacking ${tmp_dir}/${venv}.sys.tar to ${tmp_dir} ..."
    if $( tar --directory=${tmp_dir} -xf ${tmp_dir}/${venv}.sys.tar ); then
        echo "${venv}.sys.tar unpacked."
    else
        echo "Error: could not unpack ${tmp_dir}/${venv}.sys.tar to ${tmp_dir}. Check file and directory permissions."
        exit 1
    fi

    #patch the files
    echo "Patching paths in ${tmp_dir}/${venv} ..."
    files=$( grep ${venv_path_placer} -l --recursive --exclude=*.pyc ${tmp_dir}/${venv} )
    for file in $files; do
        echo "Patching $file ..."
        sed -i"" -e "s:${venv_path_placer}:${venv_root}:g" $file
    done
    files=$( grep ${project_path_placer} -l --recursive --exclude=*.pyc ${tmp_dir}/${venv} )
    for file in $files; do
        echo "Patching $file ..."
        sed -i"" -e "s:${project_path_placer}:${project_base}:g" $file
    done

    #now move the folder
    if $( mv ${tmp_dir}/${venv} ${venv_root}/ ); then
        echo "${tmp_dir}/${venv} restored."
    else
        echo "Error: could not move ${tmp_dir}/${venv} to ${venv_root}. Check file and directory permissions."
        echo "Warning: project ${project_dir} has been restored to ${project_path}. but the associated virtualenv"
        echo "failed to restore."
        echo "Warning: virtualenv files have been left in ${tmp_dir}/${venv} for diagnostics or manual restore."
        exit 1
    fi

    rm -rf ${tmp_dir}
    echo "virtualenv ${venv} restored."
}

# set tabs = 4
tabs 4

# parse out the options
OPTS=$(getopt -o dfho:ry --long force,help,outfile:,restore -- "$@")
if [[ $? -ne 0 ]]; then
    echo "Error: failed to parse command line options."
    exit 1
fi

eval set -- "$OPTS"
while true; do
    case "$1" in
        -d|--debug)
            debug=true
            shift
            ;;
        -f|--force)
            force=true
            shift
            ;;
        -h|--help)
            show_help
            ;;
        -o|--outfile)
            outfile="$2"
            shift; shift
            ;;
        -r|--restore)
            restore=true
            shift
            ;;
        -y|--no-prompt)
            no_prompt=true
            shift
            ;;
        --)
            shift
            if [ ! -z "$1" ]; then
                if [ "${restore}" = true ]; then
                    venv_file="$1"
                else
                    venv="$1"
                fi
            fi
            break
            ;;
        *)
            echo "Error: unknown option '${1}'"
            help 1
            ;;
    esac
done

# request the user to confirm the make command and exit on any
# choice other than yes.
confirm_pack() {
    echo "Create virtualenv package"
    echo "----------------------------------"
    echo "venv name: ${venv}"
    echo "venv path: ${venv_root}${venv}"
    echo "project path: ${project_path}"
    echo "package name: ${outfile}"
    echo
    read -p "Create venv package now (y/N)?" choice
    case "$choice" in
        y|Y) return;;
        *) exit 0;;
    esac
}

confirm_unpack() {
    echo "Restore virtualenv"
    echo "----------------------------------"
    echo "venv file: ${venv_file}"
    echo "venv name: ${venv}"
    echo "venv path: ${venv_root}${venv}"
    echo "project name: ${project_dir}"
    echo "project path: ${project_path}"
    echo
    read -p "Restore virtualenv now (y/N)?" choice
    case "$choice" in
        y|Y) return;;
        *) exit 0;;
    esac
}

echo "venvpack ${version}"
echo

if [ "${restore}" = "true" ]; then
    # if we're restoring make sure we have a good venv file and
    # then get the project/venv names
    if [ ! -f "${venv_file}" ]; then
        echo "Error: file '${venv_file}' not found."
        exit 1
    fi
    get_names_from_file
    ensure_venv
    if [ "${no_prompt}" = "false" ]; then
        confirm_unpack
    fi
    unpack_venv

else
    ensure_venv

    # figure out the package name
    if [ -z "${outfile}" ]; then
        outfile="${venv}.venv"
    else
        if [ -d "$outfile" ]; then
            if [[ ${outfile} != "*/" ]]; then
                outfile="${outfile}/${venv}.venv"
            else
                outfile="${outfile}${venv}.venv"
            fi
        else
            if [[ ${outfile} != "*.*" ]]; then
                outfile="${outfile}.venv"
            fi
        fi
    fi
    if [ "${no_prompt}" = "false" ]; then
        confirm_pack
    fi
    pack_venv
fi
echo "Completed."
